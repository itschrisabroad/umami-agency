'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _eventTracker = require('./components/event-tracker');

var _eventTracker2 = _interopRequireDefault(_eventTracker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OverScroll = function (_Component) {
  _inherits(OverScroll, _Component);

  /**
   * a scroll based slideshow with wings
   * @param {Object} props
   * @param {String} props.className
   * @param {render} props.children - render function for children
   * @param {string} props.anchors - allow navigation via pagers
   *                                 (`anchors='!/works'` will create a url hashbang `#!/works/[1,2,3...]``)
   *                                 (`anchors='works'` will create a url hash `#works/[1,2,3...]``)
   * @param {Number} props.slides - number of slides
   * @param {Number} [props.factor = 1] - scroll factor defines how many viewport heights page
   *  have to be scrolled to trigger the next page
   *  - 1 = 100vh
   *  - 2 = 200vh
   */
  function OverScroll(props) {
    _classCallCheck(this, OverScroll);

    var _this = _possibleConstructorReturn(this, (OverScroll.__proto__ || Object.getPrototypeOf(OverScroll)).call(this, props));

    _this.state = {
      scrollY: 0,
      counter: 0,
      scrollOffset: 0
    };
    _this.updateScroll = _this.updateScroll.bind(_this);
    return _this;
  }

  _createClass(OverScroll, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState(function () {
        return {
          scrollY: window.scrollY,
          counter: 0,
          scrollOffset: 0
        };
      });
    }
  }, {
    key: 'updateScroll',


    /**
     * checks for the current position and translates the scroll to index and percent
     * @param  {Number} scrollY - window.scrollY
     */
    value: function updateScroll(scrollY) {
      var fixed = void 0;
      var snapToBottom = void 0;
      var counter = 0;
      var scrollOffset = 0;

      // make sure the tracker element exists
      if (!this.tracker) {
        return;
      }
      // get the offset and check if the top or bottom have been reached
      // top activates the snap mode
      // bottom deactivates the snap mode

      var _tracker$getBoundingC = this.tracker.getBoundingClientRect(),
          top = _tracker$getBoundingC.top,
          bottom = _tracker$getBoundingC.bottom;

      var innerHeight = window.innerHeight || 0;
      var touchedTop = top <= 0;
      var touchedEnd = bottom <= innerHeight;
      if (touchedTop && !touchedEnd) {
        fixed = true;
        counter = Math.max(0, Math.min(this.props.slides - 1, ~~(top * (-1 / this.props.factor) / innerHeight)));
        scrollOffset = Math.max(0, Math.min(100, top * -1 % (innerHeight * this.props.factor) / innerHeight / this.props.factor * 100));
      } else if (touchedEnd) {
        snapToBottom = true;
        counter = this.props.slides - 1;
        scrollOffset = 100;
      }
      this.setState({
        scrollY: scrollY,
        fixed: fixed,
        counter: counter,
        scrollOffset: scrollOffset,
        bottom: snapToBottom
      });
    }

    /**
     * the frame is used to define the scrollable height.
     * It works as a `position: sticky` wrapper
     * @return {Object} returns a style object
     */

  }, {
    key: 'render',


    /**
     * @typedef render
     * @type Function
     * @param {Number} index - currently active index
     * @param {Number} percent - percent of active slide scrolled
     * @return {ReactNode} - returns a reactDOM element
     */
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        'div',
        { className: this.props.className },
        _react2.default.createElement(_eventTracker2.default, { onScroll: this.updateScroll }),
        _react2.default.createElement(
          'div',
          { style: this.frameStyle,
            ref: function ref(x) {
              _this2.tracker = x;
            } },
          this.anchors,
          _react2.default.createElement(
            'div',
            { style: this.overlayStyle },
            this.props.children(this.state.counter, this.state.scrollOffset, this.props.anchors)
          )
        )
      );
    }
  }, {
    key: 'frameStyle',
    get: function get() {
      var slideCount = this.props.slides;
      var factor = this.props.factor || 1;
      var vh = slideCount * 100 * factor + 100;
      return {
        height: vh + 'vh',
        position: 'relative',
        margin: 0
      };
    }

    /**
     * a polyfilled `position: sticky` helper.
     * uses the prefixed `position: sticky` style and offers a fallback with
     * `position: fixed`. The fallback requires to manually snap the box to the top and bottom
     * @return {Object} returns a position sticky polyfill
     */

  }, {
    key: 'overlayStyle',
    get: function get() {
      return {
        position: this.state.fixed ? 'fixed' : 'absolute',
        top: this.state.bottom ? 'auto' : 0,
        bottom: 0,
        left: 0,
        right: 0,
        height: '100vh'
      };
    }

    /**
     * allow to use deeplinks and clickable pagers to navigate
     * to specific pages inside the slider. Paging is done by simply jumping
     * to the correct id.
     * @return {null|ReactNode} returns a div with elements that have an id
     */

  }, {
    key: 'anchors',
    get: function get() {
      if (!this.props.anchors) {
        return null;
      }
      var anchorStyle = {
        position: 'absolute',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      var vh = 100 * (this.props.factor || 1);
      var anchors = [];
      for (var i = 0; i < this.props.slides; i++) {
        var id = this.props.anchors + '/' + (i + 1);
        var props = {
          id: id,
          key: id,
          style: {
            display: 'block',
            marginTop: i > 0 ? '1px' : 0,
            height: i > 0 ? 'calc(' + vh + 'vh - 1px)' : vh + 'vh'
          }
        };
        anchors.push(_react2.default.createElement('span', props));
      }
      return _react2.default.createElement(
        'div',
        { style: anchorStyle },
        anchors
      );
    }
  }], [{
    key: 'propTypes',
    value: function propTypes() {
      return {
        className: _react.PropTypes.string,
        children: _react.PropTypes.func.isRequired,
        anchors: _react.PropTypes.string,
        slides: _react.PropTypes.number.isRequired,
        factor: _react.PropTypes.number.isRequired
      };
    }
  }, {
    key: 'defaultProps',
    value: function defaultProps() {
      return {
        factor: 1
      };
    }
  }]);

  return OverScroll;
}(_react.Component);

exports.default = OverScroll;